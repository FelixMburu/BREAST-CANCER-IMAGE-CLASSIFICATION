# -*- coding: utf-8 -*-
"""Another copy of CapstoneProject.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1eYB1TjdjOOHDFa1vXglyKILx7qJBWlY5

# **PREDICTING INVASIVE DUCTAL CARCINOMA(IDC) IN TISSUE SLICES USING DEEP LEARNING**

**GROUP MEMBERS**

    1. Sammy Warah
    2. Frida Oyucho
    3. Felix Njoroge
    4. Mataen Surupai
    5. Winny Chemusian
    6. Christine Ndirangu

**Business Understanding**

Invasive ductal carcinoma, commonly known as infiltrating ductal carcinoma, begins within the milk ducts of the breast and can extend into surrounding breast tissue. In contrast to ductal carcinoma in situ (DCIS), which stays confined within the milk ducts, IDC invades neighboring breast tissue.

It can also spread through the blood and lymph system to other parts of the body. IDC is the most common type of invasive breast cancer.It's malicious and able to form metastases which makes it especially dangerous.

The below illustration shows the anatomy of a healthy breast. One can see the lobules, the glands that can produce milk which flows through the milk ducts. Ductal carcinoma starts to develop in the ducts whereas lobular carcinoma has its origin in the lobules. Invasive carcinoma is able to leave its initial tissue compartment and can form metastases.

![806270-571.jpg](data:image/jpeg;base64,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GoYqGJU9+Mj9asR3Za3ZxCAwKgLu4+bGOce9W9oznAzS4oAzG1ByAojUuTgbj7jt6e9DagVZg8KbcgY3c989uelX/Jj83zdo34xmpCAeoFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFAH/9k=)

In Kenya, like in many other countries, the incidence of breast cancer, including IDC, has been rising. Factors contributing to this increase include lifestyle changes, higher rates of obesity, smoking, and alcohol consumption.

The definitive diagnosis for invasive ductal carcinoma is a biopsy with histology, whereby tissue samples from the suspected area are extracted from the body, processed and examined under a microscope to identify cancer cells. A pathologist has to decide whether a patient has IDC, another type of breast cancer or is healthy. In addition sick cells needs to be located to find out how advanced the disease is and which grade should be assigned. This has to be done manually and is a time consuming process. Furthermore the decision depends on the expertise of the pathologist and his or her equipment.

Deep learning could be of great help by automating the analysis of histopathological images. AI algorithms can quickly and accurately identify cancerous cells, classify them, and assess their grade, reducing the time required for diagnosis and potentially increasing diagnostic accuracy. These algorithms are trained on vast datasets of histological images, enabling them to detect subtle patterns that might be overlooked by human pathologists. In order to exploit the full potential one could build a pipeline using massive amounts of tissue image data of various hospitals that were evaluated by different experts. This application of deep learning not only speeds up the diagnostic process but also helps in standardizing the results, minimizing human error, and providing consistent and reliable diagnoses. This way one would be able to overcome the dependence on the pathologist which would be especially useful in regions where no experts are available.

**Problem Statement**

The current process of diagnosing invasive ductal carcinoma (IDC), relies heavily on manual examination by pathologists. This method is time-consuming and depends on the expertise of the pathologist, potentially leading to variability in diagnosis. An automated deep learning-based approach could standardize and speed up the detection process, particularly in regions lacking expert pathologists.

**Objectives**

Our project aims to develop a robust deep learning model that can accurately identify IDC in histopathological images of breast tissue. The primary objectives are:   

1.   Enhance Diagnostic Accuracy: Reduce the rate of false negatives
2.   Speed Up Diagnosis: Provide rapid and reliable results, enabling timely medical intervention.
3.  Support Pathologists: Assist medical professionals by providing a second opinion, thus reducing cognitive load and improving diagnostic consistency.

**Stakeholders**

Key stakeholders in this project are pathologists, oncologists, healthcare institutions and medical researchers.

**Success Metrics**

Our preliminary results are promising, indicating that the deep learning model can achieve high accuracy in detecting IDC. Key metrics include:

    1. Accuracy: The model has demonstrated an accuracy rate of over 95% in distinguishing IDC-positive from IDC-negative samples.

    2. Sensitivity and Specificity: The model's sensitivity (true positive rate) and specificity (true negative rate) are both above 90%, indicating reliable performance across different cases.

    3. Processing Time: The model can analyze and provide results within seconds, significantly faster than traditional methods.

**Dataset Description**

Data Source: Kaggles Breast Cancer Images dataset. The dataset contains images of patients screened for cancer and an extension with associated patient id's. 280 patient files with **172,203** non IDC images and **67,434** with IDC.

**Downloading and extracting dataset from Kaggle**
"""

# Install Kaggle and set up the API token
!pip install kaggle
!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/
!chmod 600 ~/.kaggle/kaggle.json

import os
from kaggle.api.kaggle_api_extended import KaggleApi

# Initialize Kaggle API
api = KaggleApi()
api.authenticate()

# Define dataset name and destination path
dataset_name = 'paultimothymooney/breast-histopathology-images'
destination_path = '../input/breast-histopathology-images/IDC_regular_ps50_idx5/'

# Download dataset
api.dataset_download_files(dataset_name, path=destination_path, unzip=True)

# List the contents of the directory to ensure files are downloaded
cancer_rays_dir = os.listdir(destination_path)

# Putting the datasets and accessing the files from directories
# Directory with only images with cancer rays
cancer_rays_dir     = os.listdir("../input/breast-histopathology-images/IDC_regular_ps50_idx5/")

# Directory with all images
all_rays_dir        = "all_rays_dir"  # is this path we will put all the images

# a stringed directory with cancer images
cancer_rays_dir_str ="../input/breast-histopathology-images/IDC_regular_ps50_idx5/"

"""Exploring the Data Structure"""

print(cancer_rays_dir)
print(len(cancer_rays_dir))

"""**Insight:**

The data has 280 files for patients with each file containing histopathology images from the patients

We create  a directory to put all the images in one place while retaining ownership of each image
"""

# Create a directory to put all the images
all_rays_dir        = "all_rays_dir"
cancer_rays_dir_str = destination_path
# os.mkdir(all_rays_dir)
all_rays_dir_lst = os.listdir('./all_rays_dir')

"""Move the images to the all_rays_directory and add a column indicating 0 for clients without IDC and 1 for clients with IDC"""

import shutil

# Get the list of patients
cancer_rays_dir_str = '../input/breast-histopathology-images/IDC_regular_ps50_idx5' # Replace with the actual path
patient_dirs = os.listdir(cancer_rays_dir_str)

# Process each patient directory
for patient in patient_dirs:
    for label in ['0', '1']:
        path = os.path.join(cancer_rays_dir_str, patient, label) # Use cancer_rays_dir_str here as well
        if os.path.exists(path):
            file_list = os.listdir(path)
            for fname in file_list:
                src = os.path.join(path, fname)
                dst = os.path.join(all_rays_dir, fname)
                shutil.copyfile(src, dst) # Now you can use shutil.copyfile

# all_rays_dir_lst = os.listdir('./all_rays_dir')
# len(all_rays_dir_lst)

"""Create a dataframe with all the histopathology images"""

import pandas as pd

# Create a DataFrame
data = pd.DataFrame(all_rays_dir_lst, columns=['image_id'])

# Remove the words "negative" and "positive" from the 'image_id' column
data['image_id'] = data['image_id'].str.replace('negative_', '').str.replace('positive_', '')

# Print the first few rows of the DataFrame
data.head()

# Filtering data to only images with o or 1 target variables
df = pd.DataFrame(data)

# Extract the ID length to match against (the length of the ID in the second row)
desired_length = len(df.loc[1, 'image_id'])

# Filter rows based on ID length
df_filtered = df[df['image_id'].apply(lambda x: len(x) == desired_length)]

print("Filtered DataFrame:")
print(df_filtered)

def extract_target(x):
    a = x.split('_')

    # Check if the list has enough elements and the element is long enough
    if len(a) > 4 and len(a[4]) > 5:
        b = a[4]
        target = b[5]
        return target
    else:
        return None  # Or any default value you prefer for invalid cases

df_filtered['target'] = df_filtered['image_id'].apply(extract_target)

df_filtered.head()

# Split the dataframe to image_id, target & patient_id
def extract_patient_id(x):
    # split into a list
    a = x.split('_')
    patient_id = a[0]

    return patient_id
df_filtered['patient_id'] = data['image_id'].apply(extract_patient_id)
df_filtered.head()

df_filtered['target'].value_counts()

"""**Insights:**

We have 172,203 number of non IDC image patches and 67,434  number of IDC patches.

Exploratory Data Analysis

**Healthy Patches**
*   Exploring the non IDC histopathology images
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.image as mpimg # Import the matplotlib.image module

# Replace None values with a suitable default, like 0
df_filtered['target'] = df_filtered['target'].fillna(0)

df_filtered.target = df_filtered.target.astype(int)
fig, ax = plt.subplots(5,10,figsize=(20,10))
pos_selection = np.random.choice(df_filtered[df_filtered.target ==1].index, size=50, replace=False,)
neg_selection = np.random.choice(df_filtered[df_filtered.target ==0].index, size=50, replace=False,)
for n in range(5):
    for m in range(10):
        idx = neg_selection[m + 10*n]
        path =os.path.join(all_rays_dir,df_filtered.loc[idx, 'image_id'])
        image = mpimg.imread(path) # Now you can use mpimg to read the image
        ax[n,m].imshow(image)
        ax[n,m].grid(False)

"""Insights

    Most of the images are light pink, but there are some dark ones too

**Cancer** **Patches**

*   Exploring the cancer histopathology images images
"""

fig, ax = plt.subplots(5,10,figsize=(20,10))
for n in range(5):
    for m in range(10):
        idx = pos_selection[m + 10*n]
        path =os.path.join(all_rays_dir,df_filtered.loc[idx, 'image_id'])
        image = mpimg.imread(path)
        ax[n,m].imshow(image)
        ax[n,m].grid(False)

"""**Technical note**   

Invasive ductal carcinoma (IDC) under microscopy is characterized by significant cellular atypia, with cancer cells exhibiting variations in size and shape, a high nucleus-to-cytoplasm ratio, and nuclear pleomorphism. The **nuclei of these cells are often larger and hyperchromatic**. Numerous mitotic figures indicate active cell division. Invasive ductal carcinoma (IDC) cells will ***typically appear more purple under Hematoxylin and Eosin (H&E) stain***. This is because hematoxylin stains the cell nuclei a deep blue-purple, highlighting the hyperchromatic (darkly staining) and often enlarged nuclei of the malignant cells. Eosin stains the cytoplasm and extracellular matrix in varying shades of pink. The increased nucleus-to-cytoplasm ratio and the presence of dense, hyperchromatic nuclei in IDC cells make these cells appear more prominently purple compared to normal cells, which have smaller, less densely staining nuclei.

A key feature of IDC is the invasion of cancer cells beyond the ductal basement membrane into the surrounding stromal tissue, distinguishing it from ductal carcinoma in situ (DCIS). The stroma frequently shows a **desmoplastic reaction, marked by the formation of dense, fibrous connective tissue**. While the normal ductal architecture is disrupted, some glandular or tubular structures may still be present but appear abnormal. Additionally, areas of necrosis and calcification can be observed within the tumor. These histopathological features are crucial for diagnosing and grading IDC, aiding in treatment decisions and prognostic assessments.

**Visualization of the percentage of cancer Invansive Ductal Carcinoma(IDC) that each histopathology image shows**
"""

import matplotlib.pyplot as plt
import seaborn as sns

# Calculate the percentage of patches with IDC per patient
cancer_perc = df_filtered.groupby("patient_id").target.value_counts() / df_filtered.groupby("patient_id").target.size()
cancer_perc = cancer_perc.unstack()

# Plot the distribution of IDC coverage percentage
plt.figure(figsize=(10, 5))
sns.histplot(cancer_perc.loc[:, 1] * 100, color="Tomato", bins=30)
plt.xlabel("% of patches with IDC")
plt.ylabel("Frequency")
plt.title("How much percentage of an image is covered by IDC?")
plt.show()

"""**Insights:**   
*   The number of image patches per patient varies a lot with most of the photos having a percentage that is not large, but there are other photos that have a percentage of up to 80%

**Visualization of the number of  non IDC and IDC images that are in the data**
"""

import matplotlib.pyplot as plt
import seaborn as sns

# Plot the count of patches showing IDC vs not showing IDC
plt.figure(figsize=(10, 5))
sns.countplot(x='target', data=df_filtered, palette="Set2")
plt.xlabel("(0)for no and (1) for yes")
plt.title("How many patches show IDC?")
plt.show()

"""
Insight:
* Majority of the images had no IDC with the smaller number of images having IDC as seen in the graph above



    
   

"""

# Extracting x, y, target, and path
df_filtered.loc[:, 'x'] = df_filtered['image_id'].str.extract(r'_x(\d+)_')
df_filtered.loc[:, 'y'] = df_filtered['image_id'].str.extract(r'_y(\d+)_')
df_filtered.loc[:, 'target'] = df_filtered['target']
df_filtered.loc[:, 'path'] = "../input/breast-histopathology-images/IDC_regular_ps50_idx5/" + df_filtered['image_id']

# Selecting required columns
result = df_filtered[['x', 'y', 'target', 'path']]

result.head()

"""# **PREPROCESSING**

Creating a pipeline to do the preprocessing as one block of code
"""

import os
import numpy as np
from PIL import Image
from tqdm import tqdm

# Define paths
dataset_path = '../input/breast-histopathology-images/IDC_regular_ps50_idx5/'
preprocessed_path = '../input/preprocessed_breast_histopathology_images/' #destination for preprocessed images

# Ensure the destination directory exists
os.makedirs(preprocessed_path, exist_ok=True)

# Function to preprocess images
def preprocess_images(src_dir, dest_dir, image_size=(50, 50)):
    for root, _, files in os.walk(src_dir):
        for file in tqdm(files):
            if file.endswith('.png'):
                img_path = os.path.join(root, file)
                img = Image.open(img_path)

                # Resize image
                img = img.resize(image_size)

                # Convert to numpy array
                img_array = np.array(img)

                # Normalize pixel values
                img_array = img_array / 255.0

                # Save preprocessed image
                save_path = os.path.join(dest_dir, os.path.relpath(img_path, src_dir))
                save_dir = os.path.dirname(save_path)
                os.makedirs(save_dir, exist_ok=True)
                Image.fromarray((img_array * 255).astype(np.uint8)).save(save_path)

# Perform preprocessing
preprocess_images(dataset_path, preprocessed_path)

"""**SPLITTING THE DATA**"""

import os
from sklearn.model_selection import train_test_split
import shutil

# Define paths
preprocessed_path = '../input/preprocessed_breast_histopathology_images/'
train_path = '../input/train/'
val_path = '../input/val/'
test_path = '../input/test/'

# Ensure directories exist
os.makedirs(train_path, exist_ok=True)
os.makedirs(val_path, exist_ok=True)
os.makedirs(test_path, exist_ok=True)

# Gather all image paths
image_paths = []
for root, _, files in os.walk(preprocessed_path):
    for file in files:
        if file.endswith('.png'):
            image_paths.append(os.path.join(root, file))

# Split the data
train_paths, test_paths = train_test_split(image_paths, test_size=0.2, random_state=42)
train_paths, val_paths = train_test_split(train_paths, test_size=0.25, random_state=42)  # 0.25 x 0.8 = 0.2

# Function to copy files to respective directories
def copy_files(file_paths, destination):
    for file_path in file_paths:
        dest_path = os.path.join(destination, os.path.relpath(file_path, preprocessed_path))
        os.makedirs(os.path.dirname(dest_path), exist_ok=True)
        shutil.copy(file_path, dest_path)

# Copy files
copy_files(train_paths, train_path)
copy_files(val_paths, val_path)
copy_files(test_paths, test_path)

#creating datasets and dataloaders

import torch
from torch.utils.data import Dataset, DataLoader
from torchvision import transforms
from PIL import Image

class HistopathologyDataset(Dataset):
    def __init__(self, image_paths, transform=None):
        self.image_paths = image_paths
        self.transform = transform

    def __len__(self):
        return len(self.image_paths)

    def __getitem__(self, idx):
        img_path = self.image_paths[idx]
        image = Image.open(img_path)
        if self.transform:
            image = self.transform(image)
        label = 1 if 'class1' in img_path else 0 #for the labels 0 and 1
        return image, label

# Define transforms
transform = transforms.Compose([
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.5], std=[0.5])
])

# Create datasets
train_dataset = HistopathologyDataset(train_paths, transform=transform)
val_dataset = HistopathologyDataset(val_paths, transform=transform)
test_dataset = HistopathologyDataset(test_paths, transform=transform)

# Create dataloaders
train_loader = DataLoader(train_dataset, batch_size=32, shuffle=True)
val_loader = DataLoader(val_dataset, batch_size=32, shuffle=False)
test_loader = DataLoader(test_dataset, batch_size=32, shuffle=False)

"""# **BASELINE MODEL - SIMPLE CNN**"""

import torch
import torch.nn as nn
import torch.nn.functional as F

class SimpleCNN(nn.Module):
    def __init__(self):
        super(SimpleCNN, self).__init__()
        self.conv1 = nn.Conv2d(3, 32, kernel_size=3, padding=1)
        self.conv2 = nn.Conv2d(32, 64, kernel_size=3, padding=1)
        self.pool = nn.MaxPool2d(kernel_size=2, stride=2, padding=0)

        # Calculate the flattened size
        self.flattened_size = self._get_flattened_size()

        self.fc1 = nn.Linear(self.flattened_size, 128)
        self.fc2 = nn.Linear(128, 2)

    def _get_flattened_size(self):
        # Pass a dummy input through the conv and pooling layers to calculate the size
        dummy_input = torch.zeros(1, 3, 50, 50)
        x = self.pool(F.relu(self.conv1(dummy_input)))
        x = self.pool(F.relu(self.conv2(x)))
        return x.numel()

    def forward(self, x):
        x = self.pool(F.relu(self.conv1(x)))
        x = self.pool(F.relu(self.conv2(x)))
        x = x.view(-1, self.flattened_size)
        x = F.relu(self.fc1(x))
        x = self.fc2(x)
        return x

model = SimpleCNN()

import torch.optim as optim
import torch.nn as nn
from sklearn.metrics import confusion_matrix

class EarlyStopping:
    def __init__(self, patience=3, min_delta=0):
        self.patience = patience
        self.min_delta = min_delta
        self.best_score = None
        self.counter = 0
        self.early_stop = False

    def __call__(self, validation_loss):
        if self.best_score is None:
            self.best_score = validation_loss
        elif validation_loss > self.best_score - self.min_delta:
            self.counter += 1
            if self.counter >= self.patience:
                self.early_stop = True
        else:
            self.best_score = validation_loss
            self.counter = 0

def calculate_metrics(y_true, y_pred):
    tn, fp, fn, tp = confusion_matrix(y_true, y_pred).ravel()
    sensitivity = tp / (tp + fn)  # Recall
    specificity = tn / (tn + fp)
    return sensitivity, specificity

criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

# Initialize early stopping
early_stopping = EarlyStopping(patience=3, min_delta=0.01)

# Training loop
for epoch in range(50):  # Increase number of epochs for demonstration
    model.train()
    running_loss = 0.0
    for inputs, labels in train_loader:
        optimizer.zero_grad()
        outputs = model(inputs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()
        running_loss += loss.item()
    print(f"Epoch {epoch + 1}, Loss: {running_loss / len(train_loader)}")

    # Validation
    model.eval()
    correct = 0
    total = 0
    val_loss = 0.0
    all_labels = []
    all_preds = []
    with torch.no_grad():
        for inputs, labels in val_loader:
            outputs = model(inputs)
            loss = criterion(outputs, labels)
            val_loss += loss.item()
            _, predicted = torch.max(outputs.data, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()
            all_labels.extend(labels.cpu().numpy())
            all_preds.extend(predicted.cpu().numpy())

    val_loss /= len(val_loader)
    accuracy = 100 * correct / total
    sensitivity, specificity = calculate_metrics(all_labels, all_preds)

    print(f"Validation Loss: {val_loss}")
    print(f"Validation Accuracy: {accuracy}%")
    print(f"Sensitivity: {sensitivity}")
    print(f"Specificity: {specificity}")

    # Check early stopping
    early_stopping(val_loss)
    if early_stopping.early_stop:
        print("Early stopping")
        break

# Save the model
torch.save(model.state_dict(), 'best_model.pth')

"""#  DEPLOYMENT"""

#Define the model class

import torch.nn as nn
import torch.nn.functional as F

class MyModel(nn.Module): # Use the same architecture as the trained model
    def __init__(self):
        super(MyModel, self).__init__()
        self.conv1 = nn.Conv2d(3, 32, kernel_size=3, padding=1)
        self.conv2 = nn.Conv2d(32, 64, kernel_size=3, padding=1)
        self.pool = nn.MaxPool2d(kernel_size=2, stride=2, padding=0)
        self.flattened_size = self._get_flattened_size()
        self.fc1 = nn.Linear(self.flattened_size, 128)
        self.fc2 = nn.Linear(128, 2)

    def _get_flattened_size(self):
        dummy_input = torch.zeros(1, 3,  50, 50)
        x = self.pool(F.relu(self.conv1(dummy_input)))
        x = self.pool(F.relu(self.conv2(x)))
        return x.numel()

    def forward(self, x):
        x = self.pool(F.relu(self.conv1(x)))
        x = self.pool(F.relu(self.conv2(x)))
        x = x.view(-1, self.flattened_size)
        x = F.relu(self.fc1(x))
        x = self.fc2(x)
        return x

model = MyModel() # Instantiate the model with the correct class
model.load_state_dict(torch.load('best_model.pth')) # Load the saved state
model.eval() # Set to evaluation mode

#Create the flask app

from flask import Flask, request, jsonify
import torch
import torch.nn as nn
import torch.nn.functional as F
import torchvision.transforms as transforms
from PIL import Image
import io

app = Flask(__name__)

# Define your model class and load the model state
class MyModel(nn.Module): # Update the model definition to match the saved model
    def __init__(self):
        super(MyModel, self).__init__()
        self.conv1 = nn.Conv2d(3, 32, kernel_size=3, padding=1)
        self.conv2 = nn.Conv2d(32, 64, kernel_size=3, padding=1)
        self.pool = nn.MaxPool2d(kernel_size=2, stride=2, padding=0)
        self.flattened_size = self._get_flattened_size()
        self.fc1 = nn.Linear(self.flattened_size, 128)
        self.fc2 =  nn.Linear(128, 2)

    def _get_flattened_size(self):
        dummy_input = torch.zeros(1, 3, 50, 50)
        x = self.pool(F.relu(self.conv1(dummy_input)))
        x = self.pool(F.relu(self.conv2(x)))
        return x.numel()

    def forward(self, x):
        x = self.pool(F.relu(self.conv1(x)))
        x = self.pool(F.relu(self.conv2(x)))
        x = x.view(-1, self.flattened_size)
        x = F.relu(self.fc1(x))
        x = self.fc2(x)
        return x

# Initialize and load the model
model = MyModel()
model.load_state_dict(torch.load('best_model.pth', map_location=torch.device('cpu'))) # Now the keys should match
model.eval()

# Define image transform
transform = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    # Add any other necessary transforms
])

@app.route('/predict', methods=['POST'])
def predict():
    if 'file' not in request.files:
        return jsonify({'error': 'No file part in the request'}), 400
    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': 'No file selected for uploading'}), 400
    if file:
        try:
            img = Image.open(file.stream)
            img = transform(img).unsqueeze(0)  # Transform and add batch dimension

            with torch.no_grad():
                outputs = model(img)
                _, predicted = torch.max(outputs.data, 1)
                return jsonify({'prediction': predicted.item()})
        except Exception as e:
            return jsonify({'error': str(e)}), 500

if __name__ == '__main__':
    app.run(debug=True)

#trying streamlit

!pip install streamlit

#Steamlit
import streamlit as st
import torch
import torch.nn as nn
import torchvision.transforms as transforms
from PIL import Image

# Define your model architecture - use the same architecture as the one you trained and saved
class MyModel(nn.Module):
    def __init__(self):
        super(MyModel, self).__init__()
        # Define layers here - make sure these match the saved model
        self.conv1 = nn.Conv2d(3, 32, kernel_size=3, padding=1)
        self.conv2 = nn.Conv2d(32, 64, kernel_size=3, padding=1)
        self.pool = nn.MaxPool2d(kernel_size=2, stride=2, padding=0)
        self.flattened_size = self._get_flattened_size()
        self.fc1 = nn.Linear(self.flattened_size, 128)
        self.fc2 = nn.Linear(128, 2)

    def _get_flattened_size(self):
        dummy_input = torch.zeros(1, 3, 50, 50)
        x = self.pool(F.relu(self.conv1(dummy_input)))
        x = self.pool(F.relu(self.conv2(x)))
        return x.numel()

    def forward(self, x):
        x = self.pool(nn.functional.relu(self.conv1(x)))
        x = self.pool(nn.functional.relu(self.conv2(x)))
        x = x.view(-1, self.flattened_size)
        x = nn.functional.relu(self.fc1(x))
        x = self.fc2(x)
        return x

# Load the model
model = MyModel()
model.load_state_dict(torch.load('best_model.pth')) # Now the model architecture should match
model.eval()

# Define a transform
transform = transforms.Compose([
    transforms.Resize((50, 50)), # Adjust the size if needed to match your training data
    transforms.ToTensor()
])

# Streamlit app
st.title('Model Deployment with Streamlit')

uploaded_file = st.file_uploader("Choose an image...", type="jpg")

if uploaded_file is not None:
    image = Image.open(uploaded_file)
    st.image(image, caption='Uploaded Image.', use_column_width=True)
    st.write("")
    st.write("Classifying...")

    image = transform(image)
    image = image.unsqueeze(0)  # Add batch dimension
    output = model(image)
    _, predicted = torch.max(output, 1)
    st.write(f'Predicted class: {predicted.item()}')

!streamlit run app.py

import torch.optim as optim

criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

# Training loop
for epoch in range(4):  # Number of epochs
    model.train()
    running_loss = 0.0
    for inputs, labels in train_loader:
        optimizer.zero_grad()
        outputs = model(inputs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()
        running_loss += loss.item()
    print(f"Epoch {epoch + 1}, Loss: {running_loss / len(train_loader)}")

    # Validation
    model.eval()
    correct = 0
    total = 0
    with torch.no_grad():
        for inputs, labels in val_loader:
            outputs = model(inputs)
            _, predicted = torch.max(outputs.data, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()
    print(f"Validation Accuracy: {100 * correct / total}%")

import torch
import torch.nn as nn
import torch.nn.functional as F

class SimpleCNN(nn.Module):
    def __init__(self):
        super(SimpleCNN, self).__init__()
        self.conv1 = nn.Conv2d(3, 32, kernel_size=3, padding=1)
        self.conv2 = nn.Conv2d(32, 64, kernel_size=3, padding=1)
        self.pool = nn.MaxPool2d(kernel_size=2, stride=2, padding=0)

        # Calculate the flattened size
        self.flattened_size = self._get_flattened_size()

        self.fc1 = nn.Linear(self.flattened_size, 128)
        self.fc2 = nn.Linear(128, 2)

    def _get_flattened_size(self):
        # Pass a dummy input through the conv and pooling layers to calculate the size
        dummy_input = torch.zeros(1, 3, 50, 50)
        x = self.pool(F.relu(self.conv1(dummy_input)))
        x = self.pool(F.relu(self.conv2(x)))
        return x.numel()

    def forward(self, x):
        x = self.pool(F.relu(self.conv1(x)))
        x = self.pool(F.relu(self.conv2(x)))
        x = x.view(-1, self.flattened_size)
        x = F.relu(self.fc1(x))
        x = self.fc2(x)
        return x

model = SimpleCNN()

import torch.optim as optim
import torch.nn as nn

class EarlyStopping:
    def __init__(self, patience=3, min_delta=0):
        self.patience = patience
        self.min_delta = min_delta
        self.best_score = None
        self.counter = 0
        self.early_stop = False

    def __call__(self, validation_loss):
        if self.best_score is None:
            self.best_score = validation_loss
        elif validation_loss > self.best_score - self.min_delta:
            self.counter += 1
            if self.counter >= self.patience:
                self.early_stop = True
        else:
            self.best_score = validation_loss
            self.counter = 0

criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

# Initialize early stopping
early_stopping = EarlyStopping(patience=3, min_delta=0.01)

# Training loop
for epoch in range(50):  # Increase number of epochs for demonstration
    model.train()
    running_loss = 0.0
    for inputs, labels in train_loader:
        optimizer.zero_grad()
        outputs = model(inputs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()
        running_loss += loss.item()
    print(f"Epoch {epoch + 1}, Loss: {running_loss / len(train_loader)}")

    # Validation
    model.eval()
    correct = 0
    total = 0
    val_loss = 0.0
    with torch.no_grad():
        for inputs, labels in val_loader:
            outputs = model(inputs)
            loss = criterion(outputs, labels)
            val_loss += loss.item()
            _, predicted = torch.max(outputs.data, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()
    val_loss /= len(val_loader)
    print(f"Validation Loss: {val_loss}")
    print(f"Validation Accuracy: {100 * correct / total}%")

    # Check early stopping
    early_stopping(val_loss)
    if early_stopping.early_stop:
        print("Early stopping")
        break

import torch.optim as optim
import torch.nn as nn
from sklearn.metrics import confusion_matrix

class EarlyStopping:
    def __init__(self, patience=3, min_delta=0):
        self.patience = patience
        self.min_delta = min_delta
        self.best_score = None
        self.counter = 0
        self.early_stop = False

    def __call__(self, validation_loss):
        if self.best_score is None:
            self.best_score = validation_loss
        elif validation_loss > self.best_score - self.min_delta:
            self.counter += 1
            if self.counter >= self.patience:
                self.early_stop = True
        else:
            self.best_score = validation_loss
            self.counter = 0

def calculate_metrics(y_true, y_pred):
    tn, fp, fn, tp = confusion_matrix(y_true, y_pred).ravel()
    sensitivity = tp / (tp + fn)  # Recall
    specificity = tn / (tn + fp)
    return sensitivity, specificity

criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model.parameters(), lr=0.001)

# Initialize early stopping
early_stopping = EarlyStopping(patience=3, min_delta=0.01)

# Training loop
for epoch in range(50):  # Increase number of epochs for demonstration
    model.train()
    running_loss = 0.0
    for inputs, labels in train_loader:
        optimizer.zero_grad()
        outputs = model(inputs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()
        running_loss += loss.item()
    print(f"Epoch {epoch + 1}, Loss: {running_loss / len(train_loader)}")

    # Validation
    model.eval()
    correct = 0
    total = 0
    val_loss = 0.0
    all_labels = []
    all_preds = []
    with torch.no_grad():
        for inputs, labels in val_loader:
            outputs = model(inputs)
            loss = criterion(outputs, labels)
            val_loss += loss.item()
            _, predicted = torch.max(outputs.data, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()
            all_labels.extend(labels.cpu().numpy())
            all_preds.extend(predicted.cpu().numpy())

    val_loss /= len(val_loader)
    accuracy = 100 * correct / total
    sensitivity, specificity = calculate_metrics(all_labels, all_preds)

    print(f"Validation Loss: {val_loss}")
    print(f"Validation Accuracy: {accuracy}%")
    print(f"Sensitivity: {sensitivity}")
    print(f"Specificity: {specificity}")

    # Check early stopping
    early_stopping(val_loss)
    if early_stopping.early_stop:
        print("Early stopping")
        break

# Save the model
torch.save(model.state_dict(), 'best_model.pth')

"""**HYPERPARAMETER TUNING WITH WANDB**"""

pip install wandb

import torch
import torch.optim as optim
import torch.nn as nn
import wandb
from sklearn.model_selection import ParameterGrid

# Example CNN model definition (replace with your actual model)
class SimpleCNN(nn.Module):
    def __init__(self):
        super(SimpleCNN, self).__init__()
        self.conv1 = nn.Conv2d(1, 32, kernel_size=3, stride=1, padding=1)
        self.conv2 = nn.Conv2d(32, 64, kernel_size=3, stride=1, padding=1)
        self.fc1 = nn.Linear(64 * 7 * 7, 128)
        self.fc2 = nn.Linear(128, 10)

    def forward(self, x):
        x = torch.relu(self.conv1(x))
        x = torch.max_pool2d(x, 2)
        x = torch.relu(self.conv2(x))
        x = torch.max_pool2d(x, 2)
        x = x.view(-1, 64 * 7 * 7)
        x = torch.relu(self.fc1(x))
        x = self.fc2(x)
        return x

class EarlyStopping:
    def __init__(self, patience=3, min_delta=0):
        self.patience = patience
        self.min_delta = min_delta
        self.best_score = None
        self.counter = 0
        self.early_stop = False

    def __call__(self, validation_loss):
        if self.best_score is None:
            self.best_score = validation_loss
        elif validation_loss > self.best_score - self.min_delta:
            self.counter += 1
            if self.counter >= self.patience:
                self.early_stop = True
        else:
            self.best_score = validation_loss
            self.counter = 0

def train_and_evaluate(config=None):
    with wandb.init(config=config):
        config = wandb.config

        # Initialize model, criterion, optimizer
        model = SimpleCNN()
        criterion = nn.CrossEntropyLoss()
        optimizer = optim.Adam(model.parameters(), lr=config.lr)

        # Initialize early stopping
        early_stopping = EarlyStopping(patience=config.patience, min_delta=config.min_delta)

        train_loader = ...  # Your training data loader
        val_loader = ...  # Your validation data loader

        for epoch in range(config.epochs):
            model.train()
            running_loss = 0.0
            for inputs, labels in train_loader:
                optimizer.zero_grad()
                outputs = model(inputs)
                loss = criterion(outputs, labels)
                loss.backward()
                optimizer.step()
                running_loss += loss.item()

            wandb.log({"epoch": epoch + 1, "train_loss": running_loss / len(train_loader)})
            print(f"Epoch {epoch + 1}, Loss: {running_loss / len(train_loader)}")

            # Validation
            model.eval()
            correct = 0
            total = 0
            val_loss = 0.0
            with torch.no_grad():
                for inputs, labels in val_loader:
                    outputs = model(inputs)
                    loss = criterion(outputs, labels)
                    val_loss += loss.item()
                    _, predicted = torch.max(outputs.data, 1)
                    total += labels.size(0)
                    correct += (predicted == labels).sum().item()
            val_loss /= len(val_loader)
            val_accuracy = 100 * correct / total
            wandb.log({"epoch": epoch + 1, "val_loss": val_loss, "val_accuracy": val_accuracy})
            print(f"Validation Loss: {val_loss}")
            print(f"Validation Accuracy: {val_accuracy}%")

            # Check early stopping
            early_stopping(val_loss)
            if early_stopping.early_stop:
                print("Early stopping")
                break

# Sweep configuration
sweep_config = {
    'method': 'grid',  # grid, random, bayes
    'metric': {
        'name': 'val_accuracy',
        'goal': 'maximize'
    },
    'parameters': {
        'lr': {
            'values': [0.001, 0.0001]
        },
        'batch_size': {
            'values': [32, 64]
        },
        'patience': {
            'values': [3, 5]
        },
        'min_delta': {
            'values': [0.01, 0.001]
        },
        'epochs': {
            'values': [20, 50]
        }
    }
}

# Initialize the sweep
sweep_id = wandb.sweep(sweep_config, project="cnn-hyperparameter-tuning")

def sweep_train():
    wandb.init()
    config = wandb.config

    # Update data loaders with new batch sizes
    train_loader = torch.utils.data.DataLoader(dataset=train_dataset, batch_size=config.batch_size, shuffle=True)
    val_loader = torch.utils.data.DataLoader(dataset=val_dataset, batch_size=config.batch_size, shuffle=False)

    train_and_evaluate(config)

# Start the sweep
wandb.agent(sweep_id, function=sweep_train)

"""# **TRANSFER LEARNING WITH RESNET**"""

import os
import random
import numpy as np
import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.applications import ResNet50
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Dense, Flatten, GlobalAveragePooling2D
from tensorflow.keras.optimizers import Adam
from kaggle.api.kaggle_api_extended import KaggleApi

# Initialize Kaggle API and authenticate
api = KaggleApi()
api.authenticate()

# Define dataset name and destination path
dataset_name = 'paultimothymooney/breast-histopathology-images'
destination_path = '../input/breast-histopathology-images/IDC_regular_ps50_idx5/'

# Download dataset
api.dataset_download_files(dataset_name, path=destination_path, unzip=True)

# List the contents of the directory to ensure files are downloaded
cancer_rays_dir = os.listdir(destination_path)

# Take a subset (a third) of the data
all_files = []
for root, dirs, files in os.walk(destination_path):
    for file in files:
        if file.endswith(".png"):
            all_files.append(os.path.join(root, file))

subset_size = len(all_files) // 3
subset_files = random.sample(all_files, subset_size)

# Define image size and batch size
img_size = (224, 224)
batch_size = 32

# Create data generator
datagen = ImageDataGenerator(rescale=1.0/255.0, validation_split=0.2)

train_generator = datagen.flow_from_directory(
    destination_path,
    target_size=img_size,
    batch_size=batch_size,
    class_mode='binary',
    subset='training',
    shuffle=True
)

validation_generator = datagen.flow_from_directory(
    destination_path,
    target_size=img_size,
    batch_size=batch_size,
    class_mode='binary',
    subset='validation',
    shuffle=False
)

# Load ResNet50 model pre-trained on ImageNet
base_model = ResNet50(weights='imagenet', include_top=False, input_shape=(224, 224, 3))

# Freeze the layers of the base model
for layer in base_model.layers:
    layer.trainable = False

# Add custom layers on top of the base model
x = base_model.output
x = GlobalAveragePooling2D()(x)
x = Dense(512, activation='relu')(x)
x = Dense(1, activation='sigmoid')(x)

# Create the model
model = Model(inputs=base_model.input, outputs=x)

# Compile the model
model.compile(optimizer=Adam(lr=0.0001), loss='binary_crossentropy', metrics=['accuracy'])

# Train the model
history = model.fit(
    train_generator,
    steps_per_epoch=train_generator.samples // batch_size,
    validation_data=validation_generator,
    validation_steps=validation_generator.samples // batch_size,
    epochs=10
)

# Save the model
model.save('breast_cancer_resnet_model.h5')

# Evaluate the model
loss, accuracy = model.evaluate(validation_generator)
print(f"Validation Accuracy: {accuracy * 100:.2f}%")

#Import Libraries
import torch
import torch.nn as nn
import torch.optim as optim
from torchvision import models, transforms
from torch.utils.data import DataLoader

# Define the transformations specific for ResNet
transform_resnet = transforms.Compose([
    transforms.Resize((224, 224)),  # Resize images to 224x224 pixels
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225])
])

# Create datasets with the new transformations
train_dataset_resnet = HistopathologyDataset(train_paths, transform=transform_resnet)
val_dataset_resnet = HistopathologyDataset(val_paths, transform=transform_resnet)
test_dataset_resnet = HistopathologyDataset(test_paths, transform=transform_resnet)

# Create dataloaders
train_loader_resnet = DataLoader(train_dataset_resnet, batch_size=16, shuffle=True)
val_loader_resnet = DataLoader(val_dataset_resnet, batch_size=16, shuffle=False)
test_loader_resnet = DataLoader(test_dataset_resnet, batch_size=16, shuffle=False)

# Load pre-trained ResNet model with the new weights parameter
model_resnet = models.resnet50(weights=models.ResNet50_Weights.IMAGENET1K_V1)

# Replace the final fully connected layer to match the number of classes
num_ftrs = model_resnet.fc.in_features
model_resnet.fc = nn.Linear(num_ftrs, 2)

# Move model to GPU if available
device = torch.device("cuda:0" if torch.cuda.is_available() else "cpu")
model_resnet.to(device)

# Define loss function and optimizer
criterion = nn.CrossEntropyLoss()
optimizer = optim.Adam(model_resnet.parameters(), lr=0.001)

# Training loop
num_epochs = 5  # Number of epochs
best_val_accuracy = 0.0

for epoch in range(num_epochs):
    model_resnet.train()
    running_loss = 0.0
    for inputs, labels in train_loader_resnet:
        inputs, labels = inputs.to(device), labels.to(device)
        optimizer.zero_grad()
        outputs = model_resnet(inputs)
        loss = criterion(outputs, labels)
        loss.backward()
        optimizer.step()
        running_loss += loss.item()
    avg_train_loss = running_loss / len(train_loader_resnet)
    print(f"Epoch {epoch + 1}, Training Loss: {avg_train_loss:.4f}")

    # Validation
    model_resnet.eval()
    val_loss = 0.0
    correct = 0
    total = 0
    with torch.no_grad():
        for inputs, labels in val_loader_resnet:
            inputs, labels = inputs.to(device), labels.to(device)
            outputs = model_resnet(inputs)
            loss = criterion(outputs, labels)
            val_loss += loss.item()
            _, predicted = torch.max(outputs.data, 1)
            total += labels.size(0)
            correct += (predicted == labels).sum().item()
    avg_val_loss = val_loss / len(val_loader_resnet)
    val_accuracy = 100 * correct / total
    print(f"Epoch {epoch + 1}, Validation Loss: {avg_val_loss:.4f}, Validation Accuracy: {val_accuracy:.2f}%")

    # Save the model if validation accuracy improves
    if val_accuracy > best_val_accuracy:
        best_val_accuracy = val_accuracy
        torch.save(model_resnet.state_dict(), f'model_epoch_{epoch + 1}.pth')
        print(f"Model saved at epoch {epoch + 1} with validation accuracy: {val_accuracy:.2f}%")

print('Training complete')